# -*- coding: utf-8 -*-
from fmanalyser.conf import EnableableOptionHolder, options
from fmanalyser.exceptions import OutOfBoundFrequency, BadOptionValue
from fmanalyser.models.signals import scan_updated, fft_scan_updated, \
    scan_completed
from fmanalyser.utils.log import Loggable
from fmanalyser.utils.render import render_frequency
from itertools import izip
import datetime
import fmanalyser
import threading
import numpy as np

MODEL_BASIC = 'basic'
MODEL_FFT = 'fft'
MODEL_MULTISCAN = 'multiscan'
MODEL_MULTISCAN_FFT = 'multifft'
MODEL_CHOICES = (MODEL_BASIC, MODEL_FFT, MODEL_MULTISCAN, MODEL_MULTISCAN_FFT,)

class BaseBandscan(Loggable, EnableableOptionHolder):
    
    section_name = 'scan'
    
    device = options.Option(
        ini_help="Name of the device to use (as in [device:<name>] section)")
    model = options.Option(choices=MODEL_CHOICES, default=MODEL_BASIC)
    step = options.IntOption(default=100)
    partial = options.IntOption(default=10)
    exclude = options.JsonOption(default=(),
        ini_help="JSON formatted list of frequency intervals in which to skip alarm triggering")
    ref_file = options.DataFileOption(default='scan.ref')

    @classmethod
    def from_config(cls, config, subname=None, **kwargs):
        if cls is BaseBandscan:
            subcls = cls.get_subclass(cls.get_config_dict(config, subname))
            return subcls.from_config(config, subname, **kwargs)
        return super(BaseBandscan, cls).from_config(config, subname, **kwargs)

    @classmethod
    def from_config_dict(cls, confdict, subname=None, **kwargs):
        if cls is BaseBandscan:
            subcls = cls.get_subclass(confdict)
            return subcls.from_config_dict(confdict, subname, **kwargs)
        return super(BaseBandscan, cls).from_config_dict(confdict, subname, **kwargs)

    @classmethod
    def get_subclass(cls, confdict):
        model = confdict.get('model', MODEL_BASIC)
        try:
            return {
                MODEL_BASIC: Bandscan,
                MODEL_FFT: FFTBandscan,
                MODEL_MULTISCAN: MultiScan,
            }[model]
        except KeyError:
            raise BadOptionValue("invalid bandscan model: %s" % model)
    
    def __init__(self, **kwargs):
        super(BaseBandscan, self).__init__(**kwargs)
        self.init()
        self.reset()    

    def __str__(self):
        return '%s[%s..%s]' % (self.__class__.__name__,
                               render_frequency(self.start),
                               render_frequency(self.stop))
    
    def __iter__(self):
        for f, l in self.iter_interlaced():
            yield f, l

    def init(self):
        pass

    def reset(self):
        pass

    def get_next_frequency(self):
        raise NotImplementedError()

    def is_complete(self):
        raise NotImplementedError()

    def save_ref(self):
        assert self.is_complete()
        with open(self.ref_file, 'w') as fp:
            self.dump(fp)
        self.logger.info('scanning reference file saved: %s' % self.ref_file)

    def dump(self, fileobj):
        infos = {
            'version': fmanalyser.__version__,
            'now': datetime.datetime.now(),
        }
        template = """
# RF band scan generated by fmanalyser %(version)s.
# Date: %(now)s
"""
        output = template % infos
        fileobj.write(output)
        n = 0
        for f,l in self:
            fileobj.write('%s %s\n' % (f,l))
            n += 1
        return n

class BaseMultipassBandscan(BaseBandscan):

    def get_next_frequency(self):
        """Returns the next frequency without value associated or `Ç¸one` if scan is complete."""
        try:
            return self._pending[0]
        except IndexError:
            return None
    
    def is_complete(self):
        return not len(self._pending)

class Bandscan(BaseMultipassBandscan):

    start = options.CarrierFrequencyOption(default=87500)
    stop = options.CarrierFrequencyOption(default=108000)

    def init(self):
        if self.start >= self.stop:
            raise ValueError(
                "start frequency (%s) must be lower than stop frequency (%s)" % (
                self.start, self.stop))
        self._freqs = range(self.start, self.stop+self.step, self.step)

    def reset(self):
        self._pending = self._freqs[:]
        self._data = dict((f,[]) for f in self._freqs)

    def iter_interlaced(self):
        for f in self._freqs:
            levels = self._data[f]
            if levels:
                yield f, self._multipass_interlace(levels) 

    def get(self, freq, round_freq=False):
        levels = self._get_levels(freq, round_freq)
        if levels:
            return self._multipass_interlace(levels)
        return None
    
    def get_levels(self, freq, round_freq=False):
        return self._get_levels(freq, round_freq)[:]
    
    def _get_levels(self, freq, round_freq=False):
        if round_freq:
            freq = self.round_freq(freq)
        try:
            return self._data[freq]
        except KeyError:
            raise OutOfBoundFrequency(freq)
        
    def update(self, freq_levels, round_freqs=False, interlace=True):
        
        _freq_levels = list(freq_levels)
        
        if round_freqs:
            _freq_levels = [(self.round_freq(f),l) for f,l in _freq_levels]
        
        if interlace:
            d = {}
            for f,l in _freq_levels:
                d.setdefault(f,[]).append(l)
            _freq_levels = [(f,self._round_freq_interlace(lst)) for f,lst in d.iteritems()]
        
        for freq, level in _freq_levels:
            self._update(freq, level)
            self.logger.debug("%s updated : %s => %s" % (self, freq, level))
        
        scan_updated.send(self, _freq_levels)
        if self.is_complete():
            scan_completed.send(self)

    def _update(self, freq, data):
        try:
            self._pending.remove(freq)
        except ValueError:
            pass
        self._data[freq].append(data)

    def _multipass_interlace(self, lst):
        return max(lst)
    
    def _round_freq_interlace(self, lst):
        return max(lst)

class FFTHolder(object):
    
    def __init__(self, size, span, step, dc_skip, side_skip):
        self._size = size
        self._span = span
        self._step = step
        self._dc_skip = dc_skip
        self._side_skip = side_skip
        
        self._raw_freqs = np.linspace(-span/2, span/2, size)
        self._data = {}
        
        self._level_arrays = []
    
    def round_freq(self, freq):
        return int(round(freq/self._step)*self._step)
    
    def add_level_arrays(self, *level_arrays):
        assert all(len(a)==self._size for a in level_arrays)
        levels = self._add_interlace(*level_arrays)
        return self.add_levels(levels)
    
    def add_levels(self, levels):
        assert len(levels) == self._size
        m = {}
        for raw_f, l in izip(self._raw_freqs, levels):
            if abs(raw_f) < self._dc_skip:
                continue
            if abs(raw_f) > self._span/2 - self._side_skip:
                continue
            
            f = self.round_freq(raw_f)
            m.setdefault(f, []).append(l)
        
        cleaned_freqs = []
        cleaned_levs = []
        for f, levs in sorted(m.items()):
            l = self._round_interlace(levs)
            self._data.setdefault(f, []).append(l)
            cleaned_freqs.append(f)
            cleaned_levs.append(l)
        return cleaned_freqs, cleaned_levs
    
    def __iter__(self):
        for f, levs in sorted(self._data.items()):
            yield f, self._multipass_interlace(levs)
        
    def iteritems(self):
        for f, levs in self._data.iteritems():
            yield f, self._multipass_interlace(levs)
        
    def _add_interlace(self, *levels):
        levels = list(levels)
        out = levels.pop()
        while len(levels):
            out = np.maximum(out, levels.pop())
        return out
    
    def _round_interlace(self, level_list):
        return max(level_list)
    
    def _multipass_interlace(self, level_list):
        return max(level_list)
    
    @property
    def freqs(self):
        return self._freqs
    
class FFTBandscan(BaseMultipassBandscan):
    
    start = options.CarrierFrequencyOption(required=True)
    stop = options.CarrierFrequencyOption()
    jump = options.IntOption(required=True)
#    span = options.IntOption(default=0,
#        ini_help="bandwidth of each fft (0: auto)")
    dc_skip = options.IntOption(default=0,
        ini_help="width (kHz) of fft values to drop around each center frequency")
    side_skip = options.IntOption(default=0)
    
    def init(self):
        if not self.stop:
            self.stop = self.start
        
        # Value checks
        #TODO: jump/span/reject value checks (ie full band coverage check)
    
        # option fixing
        self.jump = abs(self.jump)
        if self.stop < self.start:
            self.jump = - self.jump
        
        # Data init
        self._freqs = range(self.start, self.stop+self.jump, self.jump)
    
    def reset(self):
        self._pending = self._freqs[:]
        self._data = {}
    
    def update(self, center_freq, rel_freqs, level_arrays):
        
        if center_freq not in self._data:
            self._data[center_freq] = FFTHolder(
                size = len(rel_freqs),
                span = max(rel_freqs) - min(rel_freqs),
                step = self.step,
                dc_skip = self.dc_skip,
                side_skip = self.side_skip,
            )
        holder = self._data[center_freq] 
        _freqs, _levs = holder.add_level_arrays(*level_arrays)
        
        try:
            self._pending.remove(center_freq)
        except ValueError:
            pass
        
        fft_scan_updated.send(self,
            center_freq=center_freq,
            raw_freqs = rel_freqs,
            raw_levels = level_arrays,
            cleaned_freqs = _freqs,
            cleaned_levs = _levs,
        )
        if self.is_complete():
            scan_completed.send(self)

    def get_raw_ffts(self):
        raw_ffts = []
        for cf, ffts in sorted(self._data.items()):
            for rel_freqs, levels in ffts:
                raw_ffts.append((rel_freqs + cf, levels))
        return raw_ffts
    
    def iter_interlaced(self):
        bigdata = {}
        for cf, holder in self._data.iteritems():
            for f, l in holder.iteritems():
                bigdata.setdefault(cf+f, []).append(l)

        for f, levels in sorted(bigdata.items()):
            yield f, self._overlap_interlace(levels)
    
    def _overlap_interlace(self, lst):
        return max(lst)        
        
class MultiScan(BaseBandscan):
    
    ini_help = """\
Multiscan is a bandscan that aggregates other scans ('sub-scans').
This section can define options that will be set as default for all sub-scans.
"""
    
    scans = options.CsvOption(required=True,
        ini_help="scan names assembled in this scan")
    
    @classmethod
    def from_config(cls, config, subname=None, extras=None, **kwargs):
        confdict = config.get_section(cls.section_name, subname)
        subscan_defaults = {}
        for k in confdict.keys():
            if k not in cls._options:
                subscan_defaults[k] = confdict.pop(k)
            if k in BaseBandscan._options:
                subscan_defaults[k] = confdict[k]
        subscan_names = cls._options['scans'].clean(confdict['scans'])
        subscans = []
        for subscan_name in subscan_names:
            sub_confdict = subscan_defaults.copy() 
            sub_confdict.update(config.get_section(cls.section_name, subscan_name))
            subscan = BaseBandscan.from_config_dict(sub_confdict, subscan_name)
            subscans.append(subscan)
        extras = extras or {}
        extras.setdefault('scans', subscans)
        return cls.from_config_dict(confdict, subname, extras=extras, **kwargs)
    
    def __init__(self, **kwargs):
        super(MultiScan, self).__init__(**kwargs)
        scan_completed.connect(self._scan_completed)
        
    @property
    def start(self):
        return (min(min(s.start,s.stop) for s in self.scans))

    @property
    def stop(self):
        return (max(max(s.start,s.stop) for s in self.scans))
    
    def _scan_completed(self, signal, sender):
        if sender is not self and self.is_complete():
            scan_completed.send(self)
    
    def is_complete(self):
        return all(s.is_complete() for s in self.scans)
    
    def iter_interlaced(self):
        bigdata = {}
        for scan in self.scans:
            for f,l in scan:
                bigdata.setdefault(f, []).append(l)
        for f, levels in sorted(bigdata.items()):
            yield f, self._overlap_interlace(levels)
    
    def _overlap_interlace(self, lst):
        return max(lst)   

